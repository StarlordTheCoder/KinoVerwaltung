Pascal Lernjournal
==================
Pascal Honegger
Version 1.3, 07.06.2016
:toc:

== 31.05.2016
=== CRC-Karten
Nachdem wir bereits das letzte mal mit den CRC-Karten gearbeitet haben freute ich mich gar nicht auf ein Wiedersehen. Ich bin der festen Überzeugung, dass das Erstellen eines Klassendiagrammes viel schneller und einfacher ist als das Verwalten der CRC-Karten. Falls man in einem Digital-Tool ein Klassendiagramm erstellt (wie UMLet) 

=== Module und Filter
Wir waren uns zu Beginn unschlüssig, wie wir die UX optimieren können. Um herauszufinden, wie unsere Applikation verwendet wird, haben wir die Use-Cases umstrukturiert. In diesen geht es nun mehr darum, wie der Kunde sein Ziel erreicht. So kamen wir beim Erstellen der Use-Cases auf die Schlussfolgerung, dass der User im Normalfall die verschiedenen "Module" verbinden möchte. So ist ein Use-Case das filtern / suchen von Vorstellungen. Falls man nun die Vorstellungen anhand eines Filmes suchen möchte, muss man einen Film auswählen können. Wir haben uns dafür entschieden, all diese getrennten Themen in Module aufzuteilen. So haben wir ein Film-Modul und ein Vorstellungs-Modul. In dem Film-Modul kann dann ein Film ausgewählt werden und über einen Knopf gesagt werden, dass das Vorstellungs-Modul über diesen Filter verfügt. Alle Daten, welche geladen werden, werden dann durch diese Filter gesendet und gefiltert. Dies erlaubt das dynamische hinzufügen von Filtern, dazu ist es einfach erweiterbar (Falls neue Filtermöglichkeiten dazukommen) und eine angenehme Herausforderung umzusetzen.
Die Idee ist, dass jedes Module beim Start seine Filter definieren kann. Auch andere Filtertypen (String und Date) sollten über diesen Konfigurator erstellt werden. Die Darstellung dieser Filter wird auch zentral umgesetzt und kann von jedem Modul verwendet werden.

=== DockingManager
Beim diskutieren ist die Darstellung der Module ein Thema geworden. Da wir schlussendlich viele Module darstellen müssen, obwohl der Endbenutzer nicht alle benötigt. Wir kamen schnell auf die Schlussfolgerung, dass wir ein Art von Docking verwenden möchten. Der User sollte in der Lage sein, seine Applikation so auszulegen, wie er sie benötigt. Jedes Modul sollte ein Fenster darstellen, welches man mit den anderen Fenstern kombinieren kann.
In der Arbeit verwende ich bereits ein solches Framework und habe daher Erfahrungen, wie ein solches verwendet werden kann. Damit die Applikation wirklich personalisierbar ist, muss das Layout auch beim Neustart noch das selbe sein => Es muss serialisiert werden.

=== Serialisierung => .satan & .satanData
Mithilfe der Serialisierung können wir einfach unsere Daten persistieren. Das heisst, dass sie auf die Festplatte geschrieben und von dort gelesen werden. Zu erst war unser Plan nur die Serialisierung des Layouts, doch mit der Zeit wollten wir noch mehr serialisieren. Unsere Daten wollten wir zuerst auf einem zentralen Server verwalten. Aus Zeitlichen Gründen wollten wir bereits andere Funktionen kürzen, damit dieser zentrale Server platz hat. Ich kam dabei auf die Idee, einfach jegliche Datenbank wegzulassen und die Daten in Form einer Textdatei auf dem Dateisystem des Benutzers zu speichern. Der Nachteil dabei ist, dass wir eine einzelne Datei mit allen Informationen abspeichern müssten => Man könnte nur sehr erschwert zusammen daran arbeiten (Wer zuletzt kommt überschreibt die Änderungen der Anderen!). Aus Zeitmangel entschieden wir uns dafür, diese Kompromisse einzugehen. Wir möchten zwei Dateiendungen mit unserer Applikation verbinden: 

* .satan speichert das Layout. Die Serialisierung des Layouts übernimmt das Docking-Framework.
* .satanData speichert unsere Daten. Wir möchten die Daten ansich möglichst gut kapseln, dass ein Umstieg auf einen Server mit Datenbank kein grosser Aufwänd wäre. Dies sollte auch der Testbarkeit helfen!

== 06.06.2016
=== Filter
Das Filterkonzept ist ein sehr zentrales Konzept unserer Applikation. Zuerst wollte ich ein Visitor-Pattern umsetzen. Als ich mit diesem begonnen habe viel mir aber schnell auf, dass es nicht sehr sinnvoll ist. Wir haben spezifische Datentypen und müssen diese jeweils seziell behandeln. Das neue Konzept errinert eher an ein Chain-Of-Responsibility, ist aber auch dafür keine exakte Implementation. Schlussendlich ist es eine Elegante Möglichkeit die Filter möglichst Zentral zu verwalten. Dies erlaubt es auch, die einzelnen Komponenten besser zu testen.